
二级缓存也能解决循环依赖问题，但是如果完全依靠二级缓存解决循环依赖，意味着当我们依赖了一个代理类的时候，就需要在 Bean 实例化之后就完成 AOP 代理。而在 Spring 的设计中，为了解耦 Bean的初始化 和 代理，是通过 AnnotationAwareAspectJAutoProxyCreator 这个后置处理器来在Bean生命周期的最后一步来完成 AOP 代理的。

但是，在 Spring 的初始化过程中，他是不知道哪些Bean可能有循环依赖，那么这时候Spring面临两个选择：
1. 不管有没有循环依赖，都提前把代理对象创建出来，并将代理对象缓存起来，出现依赖循环时，其他对象直接就可以取到代理对象并注入
2. 不提前创建代理对象，在出现循环依赖时，再生成代理对象。这样在没有循环依赖的情况下，Bean就可以按着Spring设计原则的步骤来创建。

第一个方案看上去比较简单，只需要二级缓存就可以了。但他也意味着，Spring需要在所有Bean的创建过程中就要完成代理对象初始化，这和Spring的 AOP 原则是相悖的。

Spring 为了不破坏 AOP 的代理设计原则，则引入第三级缓存，在三级缓存中保存对象工厂，因为通过对象工厂，可以在想要创建对象的时候直接获取对象。有了它，在后续发生循环依赖时，如果依赖的 Bean 被 AOP 代理，那么通过这个工厂获取到的就是代理后的对象，如果没有被 AOP 代理，那么这个工厂获取到的就是实例化的真实对象。