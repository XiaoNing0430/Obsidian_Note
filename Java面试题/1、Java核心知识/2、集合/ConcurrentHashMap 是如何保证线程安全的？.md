
**在 jdk1.7 中，ConcurrentHashMap 使用了分段锁技术**，即将哈希表分成多个段，每个段拥有一个独立的锁。这样可以在多个线程同时访问哈希表时，只需要锁住需要操作的那个段，那不是整个哈希表，从而提高了并发性能。

虽然 jdk1.7 的这种方式可以减少锁竞争，但是在高并发场景下，仍然会出现锁竞争，从而导致性能下降。

**在 jdk1.8 中，ConcurrentHashMap 的实现方式进行了改进，使用分段锁思想和 “CAS + Synchronized” 的机制来保证线程安全**。在 jdk1.8 中，ConcurrentHashMap 在添加元素时，如果某个段为空，那么使用 CAS 操作来添加新节点；如果段不为空，使用 Synchronized 锁住当前段，再次尝试 put。这样可以避免分段锁机制下锁的粒度太大，以及在高并发场景下，由于线程数量过多导致的锁竞争问题，提高了并发性能。

分段锁其实是一种思想。1.7中的 “分段锁” 和1.8中的 “分段锁” 不是一回事，1.7的分段锁特指他的 Segment，而 1.8 中指的是一种分段加锁的思想，加锁的时候只对当前段加锁，而不是整 Map 加锁